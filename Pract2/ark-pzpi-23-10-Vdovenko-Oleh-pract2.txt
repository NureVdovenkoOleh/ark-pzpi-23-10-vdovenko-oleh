МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторінг коду»
на тему «Методи рефакторингу коду: Replace Type Code with State/Strategy, Separate Query from Modifier, Preserve Whole Object»








Виконав:                                                           	     Перевірив:
ст. гр. ПЗПІ-23-10                                                       Старший викл. Кафедри ПІ
Вдовенко О.Д                                                         Сокорчук І.П.



Харків 2025
1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
01.11.25
0.1
Зроблена презентація та документ
2
02.11.25
0.2
Зроблені розділи 1,2,3,4,5, Додатки Б, В
3
03.11.25
0.3
Був зроблено відео й з ним Додаток А


2 ЗАВДАННЯ
     Метою даної практичної роботи є детальний аналіз та практичне застосування трьох методів рефакторингу програмного коду. Відповідно до завдання, необхідно було обрати три унікальних методи рефакторингу з книги Мартіна Фаулера "Refactoring: Improving the Design of Existing Code".
     Для цієї роботи були обрані наступні методи:
➢ Replace Type Code with State/Strategy (Заміна коду типу Станом/Стратегією), стор. 150;
➢ Separate Query from Modifier (Відокремлення запиту від модифікатора), стор. 182;
➢ Preserve Whole Object (Збереження цілого об'єкта), стор. 188.
     Ключовим аспектом завдання є демонстрація застосування цих методів на прикладах особистого коду (з курсових або лабораторних робіт), порівнюючи стан коду "до" та "після" рефакторингу.
      


3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1.  Вступ до рефакторингу
     Тема моєї доповіді — практичне застосування методів рефакторингу для покращення якості програмного забезпечення. Ця тема є надзвичайно актуальною, оскільки рефакторинг є невід'ємною частиною сучасного процесу розробки.
     Рефакторинг — це процес покращення внутрішньої структури існуючого коду без зміни його зовнішньої поведінки. Він розглядається як систематичне поліпшення, спрямоване на зменшення технічного боргу та підвищення читабельності коду. Це не одноразова дія, а постійний процес вдосконалення, який запобігає "занепаду" проекту, коли код стає занадто складним для підтримки.
     Основна мета рефакторингу — зробити код більш зрозумілим, легшим для майбутніх модифікацій та менш схильним до помилок. Таким чином, рефакторинг є важливою інвестицією у майбутнє проекту, яка окупається зменшенням витрат на подальшу розробку та підтримку.
3.2. Огляд обраних методів
   Для виконання практичної роботи було обрано три specific методи рефакторингу, кожен з яких вирішує поширені проблеми у вихідному коді та покращує його архітектуру:
       • Replace Type Code with State/Strategy (Заміна коду типу Станом/Стратегією): Цей метод спрямований на заміну кодів типу, які часто контролюють поведінку через умовні конструкції (наприклад, if або switch), на повноцінні об'єкти з власною поведінкою. Це дозволяє видалити складні умовні конструкції та зробити систему більш гнучкою до додавання нових типів.
       • Separate Query from Modifier (Відокремлення запиту від модифікатора): Принцип цього методу полягає у чіткому розділенні методів, які повертають дані (запити), від методів, які змінюють стан об'єкта (модифікатори). Такий підхід робить код більш передбачуваним, запобігає неочікуваним побічним ефектам і спрощує тестування.
       • Preserve Whole Object (Збереження цілого об'єкта): Замість того, щоб передавати у метод велику кількість окремих полів, отриманих з одного об'єкта, цей метод пропонує передавати сам об'єкт цілком. Це значно зменшує кількість параметрів методу, робить його сигнатуру чистішою та надає методу гнучкість у використанні даних об'єкта.
     Застосування цих методів допомагає покращити загальну архітектуру коду, роблячи його більш гнучким до змін, простішим для розуміння та менш схильним до помилок
3.3.  Метод Replace Type Code with State/Strategy
     Цей метод рефакторингу пропонує замінити примітивні коди типу (наприклад, числа або рядки, що позначають стан) на повноцінні об'єкти, які інкапсулюють власну поведінку.
     Проблема, яку вирішує метод, виникає, коли логіка програми значною мірою покладається на умовні конструкції (такі як if або switch) для визначення поведінки на основі цих примітивних значень. Це робить код складним для підтримки та розширення.
     Рішення полягає у створенні ієрархії класів (відповідно до патернів "Стан" або "Стратегія"), де кожен окремий клас-стан інкапсулює логіку поведінки, що відповідає конкретному значенню коду типу.
     Переваги такого підходу очевидні:
        • Він видаляє складні та громіздкі умовні конструкції.
        • Значно полегшує додавання нової поведінки (станів), оскільки достатньо додати новий клас, не змінюючи існуючий код.
        • Покращує загальну читабельність коду, роблячи його більш об'єктно-орієнтованим.
     Водночас, метод має певні недоліки:
        • Він призводить до збільшення загальної кількості класів у системі.
        • Існує ризик надлишкового ускладнення (over-engineering), якщо метод застосовується у дуже простих випадках з невеликою кількістю станів.
        • Відладка може стати складнішою через появу багатьох дрібних об'єктів.
     Враховуючи це, даний метод рефакторингу найкраще використовувати у ситуаціях, коли система має багато станів, логіка цих станів часто змінюється, або коли код свідомо планується до подальшого розширення.
Практичне застосування:
     У вихідному коді був метод FilterCuriosities, який використовував конструкцію switch для вибору логіки пошуку на основі рядкового параметра searchCriteria. Цей підхід є негнучким, оскільки додавання нового критерію пошуку вимагатиме модифікації цього методу, що демонструє код "до" рефакторингу (Див. Додаток В.1).
     Для рефакторингу було застосовано патерн "Стратегія". Було створено інтерфейс ISearchStrategy та його конкретні реалізації (TextSearch, AuthorSearch, TypeSearch). Кожен клас-стратегія інкапсулює власну логіку пошуку. Цей підхід "після" рефакторингу показаний у (Див. Додаток В.2).
     В результаті рефакторингу код став значно гнучкішим. Тепер для додавання нової стратегії пошуку достатньо створити новий клас, що реалізує інтерфейс ISearchStrategy, без необхідності змінювати існуючу логіку, яка керує фільтрацією
3.4. Метод Separate Query from Modifier
     Даний метод рефакторингу базується на принципі Command-Query Separation (CQS), який вимагає чіткого розділення методів на дві категорії: "запити" (queries) та "модифікатори" (modifiers).
     Проблема, яку він вирішує, виникає, коли один і той самий метод одночасно змінює стан об'єкта (має побічні ефекти) і повертає певне значення. Це призводить до плутанини, створює неочікувані побічні ефекти та значно ускладнює розуміння коду. Неможливо викликати такий метод для отримання даних, не ризикуючи при цьому випадково змінити стан системи. Рішення полягає у строгому розділенні методів на два типи. Запити (Queries) — це методи, які тільки повертають дані та не мають жодних побічних ефектів (тобто не змінюють стан об'єкта). Натомість модифікатори (Modifiers) — це методи, які тільки змінюють стан об'єкта та, як правило, нічого не повертають.
     Переваги такого підходу полягають у тому, що код стає набагато більш передбачуваним, прозорим та легшим для тестування. Зникає ризик прихованих побічних ефектів, оскільки виклик методу-запиту гарантовано не змінить стан системи. Даний метод рефакторингу базується на принципі Command-Query Separation (CQS), який вимагає чіткого розділення методів на дві категорії: "запити" (queries) та "модифікатори" (modifiers). Водночас, існують і певні недоліки. Зокрема, це призводить до збільшення загальної кількості методів у класі, і сам метод може здатися надлишковим для дуже простих операцій. Крім того, для виконання простих дій, які раніше поєднувались (наприклад, отримати значення і одразу його змінити), може знадобитися виклик двох окремих методів замість одного.
     Тому цей метод рефакторингу найкраще застосовувати для критичних операцій, де відбувається зміна важливого стану і де передбачуваність поведінки є пріоритетом.
     Практичне застосування:
     У вихідному коді був присутній метод GetRandom, який порушував принцип CQS. Він одночасно виконував дві задачі: повертав випадковий об'єкт Curiosity (запит) та записував дію у actionHistory (модифікація стану). Це створювало неочікуваний побічний ефект: простий виклик методу для отримання даних призводив до зміни історії дій (Див. Додаток В.3).
     Під час рефакторингу цей метод було розділено на два окремих. Перший — це запит (Query) GetRandomCuriosity(), який займається виключно отриманням та поверненням випадкового об'єкта. Другий — це модифікатор (Modifier) LogRandomAccess(), який займається виключно логуванням дії, тобто зміною стану. Цей підхід "після" рефакторингу наведено у (Див. Додаток В.4).
     В результаті, код став чистішим і більш передбачуваним. Тепер отримання даних та логування – це дві окремі, явні операції, що виключає приховані побічні ефекти.
3.5. Метод Preserve Whole Object
     Сутність цього методу рефакторингу полягає у тому, щоб замінити передачу у метод набору окремих полів на передачу одного цілого об'єкта, якому ці поля належать.
     Проблема, яку він вирішує, є дуже поширеною: це наявність методів з довгою сигнатурою (великою кількістю параметрів), які отримують багато даних, що логічно є частинами однієї сутності (наприклад, дані з одного об'єкта чи форми). Це ускладнює читання, виклик та подальшу підтримку такого коду. Рішення полягає у тому, щоб інкапсулювати всі ці логічно пов'язані дані в один об'єкт (часто це простий клас даних, DTO, або спеціальний об'єкт параметрів) і передавати у метод лише цей єдиний об'єкт.
     Переваги такого підходу значні: він радикально зменшує кількість параметрів, що миттєво покращує читабельність сигнатури методу. Окрім того, він спрощує майбутнє розширення, оскільки додавання нового поля даних не вимагає зміни сигнатури методу в усіх місцях його виклику — достатньо додати нове поле до об'єкта параметрів. Водночас, існують і певні недоліки. Цей метод може призвести до створення зайвих класів даних, які слугують лише "контейнерами" для параметрів. Він не є ефективним і може бути надлишковим для простих випадків, де метод приймає всього два-три параметри. Також існує ризик, що метод стане надмірно залежним від внутрішньої структури цього об'єкта.
     З огляду на це, метод "Preserve Whole Object" найкраще застосовувати для методів, що мають чотири або більше параметрів, особливо коли ці параметри логічно пов'язані між собою.
     Практичне застосування:
     У вихідному коді метод FilterCuriosities мав декілька параметрів, що відповідали за критерії пошуку (searchText, searchCriteria, filterByFavorites). Це робило сигнатуру методу складною для читання та, що важливіше, для розширення — наприклад, додавання фільтру за датою вимагало б зміни методу в усіх місцях. Цей стан "до" рефакторингу наведено у (Див. Додаток В.5).
     Під час рефакторингу було створено новий клас SearchParameters, який об'єднав усі ці поля в один об'єкт. Тепер метод FilterCuriosities приймає лише один параметр — об'єкт SearchParameters. Цей підхід "після" рефакторингу показано у (Див. Додаток В.6).
     В результаті код став значно чистішим. Тепер для додавання нового параметра пошуку (наприклад, DateFrom) достатньо модифікувати клас SearchParameters, не змінюючи сигнатуру методу FilterCuriosities та місця його виклику.
3.6. Результати рефакторингу
     Застосування трьох обраних методів рефакторингу мало комплексний позитивний вплив на якість коду, його архітектуру та подальшу підтримку. Кожен метод вирішив конкретні проблеми, що в сумі призвело до значного покращення проекту.
     Метод Replace Type Code with State/Strategy (Розділ 3.3) дозволив усунути жорстку switch-конструкцію, що є поширеним "запахом коду". Це надало архітектурі значно більшої гнучкості: тепер додавання нових критеріїв пошуку не вимагає модифікації існуючого коду, а зводиться до створення нового класу-стратегії.
     Метод Separate Query from Modifier (Розділ 3.4) суттєво підвищив передбачуваність системи. Через чітке розділення методу, що повертав дані, та методу, що логував дію, ми позбулися неочікуваних побічних ефектів. Тепер розробник, який викликає функцію отримання даних, може бути впевнений, що цей виклик не призведе до прихованих змін стану системи.
     Метод Preserve Whole Object (Розділ 3.5) безпосередньо покращив простоту використання та читабельність коду. Завдяки інкапсуляції параметрів пошуку в один об'єкт, сигнатура методу фільтрації стала чистою та лаконічною. Це не лише полегшує читання, але й робить код значно простішим для розширення у майбутньому.
     Загалом, проведені зміни призвели до того, що код стало легше додавати новий функціонал та вносити зміни з меншою ймовірністю виникнення помилок. Зменшення складності та усунення побічних ефектів також покращили тестованість окремих компонентів. Таким чином, рефакторинг не лише покращив поточну якість коду, але й підвищив загальну ефективність подальшої розробки.
3.7. Інструменти рефакторингу
     Хоча рефакторинг, описаний у попередніх розділах, можна виконувати вручну, сучасні середовища розробки (IDE) та спеціалізовані інструменти роблять цей процес значно безпечнішим та ефективнішим. Вони автоматизують складні перетворення коду, мінімізуючи ризик людської помилки.
     Основою для розробника на C# є вбудовані інструменти рефакторингу Visual Studio. Вони надають базовий, але надійний набір функцій, доступних через контекстне меню, таких як безпечне "Перейменування" (Rename), "Виділення методу" (Extract Method) та "Інлайнінг" (Inline). Ці засоби гарантують, що зміни будуть коректно застосовані у всьому проекті. Для більш глибокого аналізу та автоматизації часто використовуються потужні сторонні розширення, серед яких лідером є ReSharper. Цей інструмент не лише пропонує набагато ширший каталог автоматичних рефакторингів, але й проводить безперервний аналіз якості коду "на льоту", пропонуючи покращення та вказуючи на "запахи коду" ще до того, як вони стануть проблемою. Окремо варто відзначити критично важливу роль систем контролю версій (наприклад, Git). Хоча це не інструмент рефакторингу в прямому сенсі, він є "страхувальною сіткою" для розробника. Контроль версій дозволяє безпечно експериментувати зі значними змінами у коді, створюючи окремі гілки, та миттєво відкочувати будь-які невдалі спроби, які призвели до помилок або втрати функціональності.
     Таким чином, поєднання сучасних IDE, спеціалізованих розширень та систем контролю версій перетворює рефакторинг на керований, безпечний та високоефективний процес, що дозволяє постійно покращувати код без ризику пошкодити існуючу функціональність
     
     


4 
ВИСНОВКИ
     Під час виконання даної практичної роботи було детально проаналізовано та застосовано три фундаментальні методи рефакторингу. Виконана робота практично підтвердила, що рефакторинг є критично важливою та невід'ємною складовою сучасної розробки програмного забезпечення. Це не одноразова дія, а безперервний процес, який дозволяє підтримувати "здоров'я", гнучкість та ефективність кодової бази протягом усього її життєвого циклу. Застосування обраних методів — Replace Type Code with State/Strategy, Separate Query from Modifier та Preserve Whole Object — наочно продемонструвало, як системний підхід до покращення коду може трансформувати потенційно жорстку або монолітну структуру в більш модульну, гнучку та керовану архітектуру. Ми побачили, як усунення умовних конструкцій, розділення відповідальності методів та спрощення їхніх сигнатур безпосередньо впливає на якість коду.
     У підсумку, ця робота доводить, що рефакторинг — це не просто "прибирання коду" чи косметичне покращення. Це стратегічна інвестиція у майбутнє проекту. Вона безпосередньо зменшує накопичений технічний борг, що, у свою чергу, покращує продуктивність команди розробників та забезпечує стабільність системи при неминучих подальших змінах вимог. Таким чином, код стає більш легким для підтримки, модифікації та розширення
    

5 СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ
      1. Fowler M. Refactoring: Improving the Design of Existing Code. Addison-Wesley Professional, 1999. 464 p.
      2. Visual Studio documentation. Microsoft Learn. URL: https://learn.microsoft.com/uk-ua/visualstudio/ (date of access: 01.11.2025).
      3. Stack Overflow. URL: https://stackoverflow.com/ (date of access: 01.11.2025).
      

ДОДАТОК А
Посилання відео на Youtube
Відеозапис доповіді: https://www.youtube.com/watch?v=cYiUUmKbeAY
Хронологічний опис відеозапису:
0:00 - Вступ
0:12 - Вступ до рефакторингу
1:04 - Огляд обраних методів
1:53 - Пояснення першего методу (Replace Type Code With State/Strategy)
2:50 - Застосування першего методу (Replace Type Code With State/Strategy)
3:46 - Пояснення другого методу (Separate Query from Modifier)
4:41 - Застосування другого методу (Separate Query from Modifier)
5:31 - Пояснення третього методу (Preserve Whole Object)
6:20 - Застосування третього методу (Preserve Whole Object)
7:10 - Результати рефакторингу
7:50 - Інструменти рефакторингу
8:32 - Висновки
9:10 - Список джерел

ДОДАТОК Б
Слайди презентації
         
      
         
         
      
      
         
      


































ДОДАТОК В
Програмний код
В.1 Метод "Replace Type Code with State/Strategy" – "До" рефакторингу 
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract2/pzpi-23-10-vdovenko-oleh-pract2/code_examples_refactoring_methods.cs
public List FilterCuriosities( 
    string searchText, string searchCriteria) 
{ 
    switch (searchCriteria) 
    { 
        case "Текст": 
            return curiosities.Where(c => 
                c.Text.Contains(searchText)); 
        case "Автор": 
            return curiosities.Where(c => 
                c.Author.Contains(searchText)); 
        case "Тип": 
            return curiosities.Where(c => 
                c.Type.Contains(searchText)); 
    } 
}
В.2 Метод "Replace Type Code with State/Strategy" – "Після" рефакторингу 
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract2/pzpi-23-10-vdovenko-oleh-pract2/code_examples_refactoring_methods.cs
public interface ISearchStrategy 
{ 
    List Search(string searchText, 
        List curiosities); 
} 

public class TextSearch : ISearchStrategy 
{ 
    public List Search(string 
        searchText, 
        List curiosities) 
    { 
        return curiosities.Where(c => 
            c.Text.Contains(searchText)).ToList(); 
    } 
} 
//Так же само для AuthorSearch, TypeSearch
В.3 Метод "Separate Query from Modifier" – "До" рефакторингу 
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract2/pzpi-23-10-vdovenko-oleh-pract2/code_examples_refactoring_methods.cs
// --- В.3 Метод "Separate Query from Modifier" – "До" рефакторингу ---

public Curiosity GetRandom() 
{ 
    actionHistory.AddAction("Отримано випадковий 
        курйоз"); 
    // МЕТОД І ПОВЕРТАЄ ДАНІ, І ЗМІНЮЄ СТАН! 
    Random random = new Random(); 
    int index = random.Next(curiosities.Count); 
    return curiosities[index]; 
}
В.4 Метод "Separate Query from Modifier" – "Після" рефакторингу 
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract2/pzpi-23-10-vdovenko-oleh-pract2/code_examples_refactoring_methods.cs
// ЗАПИТ - тільки повертає дані 
public Curiosity GetRandomCuriosity() 
{ 
    Random random = new Random(); 
    int index = random.Next(curiosities.Count); 
    return curiosities[index]; 
} 

// МОДИФІКАТОР - тільки змінює стан 
public void LogRandomAccess() 
{ 
    actionHistory.AddAction("Отримано випадковий 
        курйоз"); 
} 

// ВИКОРИСТАННЯ: 
var randomCuriosity = GetRandomCuriosity(); 
LogRandomAccess();
В.5 Метод "Preserve Whole Object" – "До" рефакторингу 
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract2/pzpi-23-10-vdovenko-oleh-pract2/code_examples_refactoring_methods.cs
public List FilterCuriosities( 
    string searchText, 
    string searchCriteria, 
    bool filterByFavorites = false) 
// багато параметрів - складно читати 
{
    // ...
}
В.6 Метод "Preserve Whole Object" – "Після" рефакторингу 
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract2/pzpi-23-10-vdovenko-oleh-pract2/code_examples_refactoring_methods.cs			
public class SearchParameters 
{ 
    public string SearchText { get; set; } 
    public SearchCriteria Criteria { get; set; } 
    public bool FilterByFavorites { get; set; } 
    // Легко додати: public DateTime DateFrom { get; set; }  
} 

public List FilterCuriosities(SearchParameters parameters) 
// один параметр - просто та зрозуміло 
{
    // ...
}

24


