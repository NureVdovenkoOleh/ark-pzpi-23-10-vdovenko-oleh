МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з практичної роботи №1
з дисципліни «Аналіз та рефакторінг коду»
на тему «Стандарти оформлення коду з використанням інструментів tidyverse, lintr, styler та тестувань testthat для мови програмування R»








Виконав:                                                           	     Перевірив:
ст. гр. ПЗПІ-23-10                                                       Старший викл. Кафедри ПІ
Вдовенко О.Д                                                          Сокорчук І.П.




Харків 2025
1. ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень130.09.250.1Зроблено розділи 2,3,4,5 та «Додаток Б» й презентація, оформлення звіту25.10.250.2Виправляємо оформлення321.10.250.3Додаємо додаток В, виправляємо оформлення, закінчуємо додаток А2. 

   2. ЗАВДАННЯ
      Ознайомитися з основними принципами та правилами написання якісного, зрозумілого та структурованого коду на мові програмування R. Необхідно не лише вивчити теоретичні засади, але й сформувати стійкі практичні навички їх застосування під час виконання реальних завдань та розробки проектів. Ключовим аспектом завдання є практична демонстрація того, наскільки суворе дотримання принципів чистого коду впливає на процес розробки. Потрібно показати, як структурований підхід та чіткі правила стилю безпосередньо допомагають уникнути типових логічних та синтаксичних помилок, значно підвищують читабельність коду для інших розробників та для самого автора в майбутньому, роблять його більш надежним та передбачуваним, а також істотно полегшують його подальшу підтримку, модифікацію та масштабування.
      

3. ОПИС ВИКОНАНОЇ РОБОТИ
1. 
2. 
2.1. Вступ
      Тема моєї доповіді — основні рекомендації написання коду на мові програмування R. Ця тема є актуальною, адже R широко застосовується у статистиці, аналізі даних, машинному навчанні та наукових дослідженнях, і його використовують не лише програмісти, а й спеціалісти з різних галузей. У таких умовах зрозумілість і якість коду мають вирішальне значення, адже він повинен бути придатним для командної роботи та довгострокової підтримки. У своїй роботі я розгляну ключові принципи, які допомагають робити код більш читабельним, логічним і професійним.
2.2. Причини важливості правил оформлення коду
      Правила оформлення коду відіграють надзвичайно важливу роль у створенні зрозумілих, підтримуваних і надійних програм. У мові R, яка часто використовується для аналізу даних, статистики та наукових досліджень, правильне оформлення коду дозволяє швидко орієнтуватися у логіці програми, навіть якщо її читає інша людина або сам автор через деякий час. Недотримання правил веде до хаотичного коду, у якому складно знаходити помилки, перевіряти логіку і доповнювати функціонал, що значно ускладнює командну роботу і знижує ефективність проєкту. Дотримання правил оформлення коду забезпечує високий рівень читабельності та зрозумілості. Наприклад, використання зрозумілих імен змінних і функцій, відступів, логічного поділу на блоки та коментарів дозволяє миттєво зрозуміти, яку роль виконує кожен елемент програми. Це не лише економить час на аналіз і налагодження, а й зменшує ймовірність помилок, які важко відстежити у великому проєкті. Крім того, правила оформлення коду спрощують його тестування та інтеграцію з різними інструментами автоматизації. У R існують спеціальні пакети, такі як lintr та styler, які перевіряють стиль коду та автоматично виправляють його, але вони ефективні лише тоді, коли код уже структурований відповідно до базових стандартів. В результаті дотримання правил оформлення коду підвищує надійність і довговічність програмних рішень, робить їх більш зрозумілими для команди і полегшує підтримку та розвиток проєкту.
2.3. Структура коду в R
      Правильна структура коду дозволяє робити програми зрозумілими та легкими для підтримки. У R великі скрипти без логічного поділу важко читати, а зміни чи повторне використання коду стають проблемою. Щоб цього уникнути, рекомендується розділяти код на логічні блоки (Див. Додаток В.1), використовувати функції для повторюваних операцій і при великих проєктах ділити код на окремі файли, підключаючи їх через source (“file.R”). У такому випадку код поділено на невеликі модулі, його легко редагувати та тестувати окремо, що робить проєкт більш зрозумілим і зручним для роботи команди.
2.4. Форматування коду
      Форматування коду допомагає зробити його більш читабельним і зрозумілим. У R важливо дотримуватися відступів, вирівнювання та обмежень на довжину рядків, щоб швидко орієнтуватися у програмі та уникати помилок. Відступи полегшують сприйняття вкладених конструкцій, таких як цикли та умовні оператори, а чітке вирівнювання коду робить логіку видимою одразу (Див. Додаток В.2).
2.5. Іменування змінних і функцій
      Правильне і зрозуміле іменування змінних і функцій є одним із ключових правил написання чистого коду в R. Використання змістовних назв допомагає швидко зрозуміти, що саме робить код, і спрощує його підтримку та повторне використання. У R для змінних і функцій зазвичай застосовується стиль snake_case, а для класів чи об’єктів іноді використовується PascalCase, хоча це трапляється рідко. Не рекомендується використовувати однобуквові або абстрактні імена, які не дають уявлення про призначення змінної чи функції. Такі імена значно ускладнюють читання коду, особливо коли скрипт великий або його читає інший розробник. У цьому випадку (Див. Додаток В.3) імена a та f нічого не пояснюють, і код важко підтримувати та використовувати повторно.
      Змістовні імена одразу показують (Див. Додаток В.4) , яку роль виконує кожен елемент. Це підвищує читабельність, полегшує налагодження та дозволяє безпечно повторно використовувати функції в інших частинах проєкту. Дотримання правил іменування є важливим кроком для створення зрозумілого та професійного коду, який легко підтримувати та масштабувати.
2.6. Константи та «магічні» числа
      «Магічні числа» — це числові значення, які з’являються у коді без пояснення і не мають змістовної назви. Використання таких чисел ускладнює розуміння програми, підвищує ризик помилок і робить підтримку коду більш трудомісткою. Щоб цього уникнути, рекомендується виносити такі значення у змінні або константи з інтуїтивно зрозумілими іменами. Константи підвищують гнучкість коду: якщо потрібно змінити значення, достатньо зробити це в одному місці, замість того щоб редагувати його у багатьох рядках. Крім того, використання констант допомагає уникнути дублювання коду та полегшує його читання і тестування (Див. Додаток В.5). У цьому випадку значення 0.85 нічого не пояснює, і код важко підтримувати
      Тут (Див. Додаток В.6) константа DISCOUNT_RATE пояснює, що саме означає число, робить код більш зрозумілим і дозволяє легко змінювати логіку розрахунку без пошуку числових значень по всьому скрипту. Використання констант і «зрозумілих чисел» — це простий, але ефективний спосіб підвищити якість і підтримуваність коду.
2.7. Коментарі
      Коментарі в R використовуються для пояснення логіки коду і позначаються символом #. Вони не виконуються програмою, але допомагають розробникам швидко зрозуміти, що робить код, особливо у складних алгоритмах або нестандартних обчисленнях. Важливо не коментувати очевидні дії, адже надлишкові коментарі лише захаращують код і знижують його читабельність. Правильне використання коментарів допомагає структурувати код блоками, виділяти складні обчислення або алгоритми та полегшує роботу команди. Коментарі мають пояснювати логіку, а не дублювати очевидні дії, щоб код залишався чистим і зрозумілим. Тут (Див. Додаток В.7) коментарі пояснюють очевидні дії, що не додає цінності і робить код менш читабельним.
      У цьому випадку (Див. Додаток В.8) коментарі пояснюють, для чого виконуються обчислення, а не просто повторюють код. Такий підхід робить код зрозумілим, полегшує внесення змін та підтримку програми. Структурування коментарів блоками також допомагає швидко орієнтуватися у великих скриптах і покращує співпрацю в команді.
2.8. Документування функцій
      Документування функцій у R пояснює призначення функції, її параметри та результат. Це особливо важливо для командної роботи та створення пакетів, адже допомагає іншим розробникам швидко розібратися у коді, зрозуміти логіку функції та спосіб її використання. У R для цього часто застосовується пакет roxygen2, який дозволяє створювати структуровану документацію безпосередньо у файлі з кодом. Відсутність документації ускладнює розуміння коду навіть для автора через деякий час і робить використання функцій у проєкті менш зручним. Зрозумілі імена змінних та докладні коментарі підвищують читабельність і спрощують повторне використання коду. Тут (Див. Додаток В.9) відсутня документація, назви змінних не пояснюють, що саме робить функція, і її важко використовувати без додаткового аналізу.
      У цьому прикладі (Див. Додаток В.10) документація робить функцію зрозумілою, пояснює параметри та результат, а також містить приклад використання. Такий підхід підвищує зручність роботи з кодом, спрощує тестування та повторне використання функцій у різних частинах проєкту.
      
      
2.9. Обробка помилок
      Обробка помилок є важливою частиною написання надійного та стійкого коду. Вона дозволяє передбачати можливі проблеми у роботі програми й надавати користувачеві зрозумілі повідомлення про причини збою. У R для цього застосовуються функції stop(), warning() та message(). Для більш складних сценаріїв, коли необхідно відловлювати винятки й контролювати виконання програми, використовується конструкція tryCatch(). Правильно організована обробка помилок спрощує тестування, підвищує зручність використання коду та знижує ризик некоректної роботи програми. Важливо не лише перехоплювати помилки, а й пояснювати їх у повідомленнях так, щоб користувач або розробник одразу розумів, у чому проблема. У цьому випадку (Див. Додаток В.11) відсутня обробка помилок: поділ на нуль призведе до аварійного завершення програми, а користувач не отримає пояснення.
      Тут (Див. Додаток В.12)  функція safe_divide попереджає про помилку зрозумілим повідомленням, а конструкція tryCatch дозволяє програмі продовжити роботу навіть після виникнення винятку. Такий підхід робить програму більш гнучкою, безпечною та зручною для користувачів.
2.10. Тестування 
      Тестування — це ключовий інструмент забезпечення якості програмного коду. Воно гарантує, що функції працюють правильно, і дозволяє швидко виявляти помилки після змін у програмі. У мові R стандартним рішенням для написання unit tests є пакет testthat, який забезпечує зручний синтаксис і простоту перевірки різних випадків використання. Наявність тестів робить рефакторинг безпечнішим і зменшує ризик появи регресій — ситуацій, коли після змін у коді перестає працювати те, що раніше працювало. Поширений підхід — TDD (Test-Driven Development): спочатку пишуть тест, а вже потім реалізують функцію. Це дозволяє відразу чітко сформулювати очікувану поведінку коду.
      У цьому випадку (Див. Додаток В.13) немає жодних перевірок: якщо функція міститиме помилку, її можна виявити лише вручну
      Тут (Див. Додаток В.14) тести перевіряють різні випадки: додатні, від’ємні та нульові значення. Це дає впевненість у правильності роботи функції й дозволяє відразу виявити помилки після будь-яких змін у коді. Тестування — це не лише технічна практика, а й важливий підхід до підтримки стабільності проєкту. Воно робить код надійним, зрозумілим і зручним у довгостроковій перспективі.
2.11. Інструменти автоматизації
      Автоматизація значно спрощує підтримку єдиного стилю коду у команді та допомагає уникати хаосу в проєкті. У мові R для автоматизації підтримки стилю найчастіше застосовуються lintr та styler. Пакет lintr аналізує код і виявляє порушення правил оформлення, наприклад неправильні відступи, надто довгі рядки чи невдалі назви змінних, а styler автоматично виправляє форматування, приводячи код до узгодженого стандартного вигляду. Разом ці інструменти допомагають підтримувати чистоту та єдність стилю в проєкті, зменшують кількість дрібних правок у команді та дозволяють розробникам зосередитися на логіці програми, а не на технічних деталях оформлення. Завдяки таким інструментам програмісти можуть зосередитися на логіці й алгоритмах, а не витрачати зусилля на ручне виправлення стилю. Це також знижує ризик конфліктів у системах контролю версій, коли кілька людей працюють над одним файлом.
      Тут (Див. Додаток В.15) відсутні єдині правила: різний стиль відступів, використання = замість <-, «злиплий» код без пробілів. У результаті проєкт швидко стає нечитабельним.
      У цьому випадку (Див. Додаток В.16) код відформатовано автоматично: зрозумілі відступи, правильні пробіли та стиль назв. Це робить його охайним, легким для сприйняття та підтримки. Автоматизація стилю коду — важливий крок для командної роботи, адже вона забезпечує єдність оформлення, економить час і допомагає уникнути зайвих суперечок між розробниками.
2.12. Поганий vs Хороший код
      Порівняння поганого й хорошого коду наочно показує, наскільки великий вплив має стиль програмування на зрозумілість і підтримку проєкту. Код без структури, коментарів та з хаотичними іменами змінних швидко стає важким для читання і призводить до помилок під час роботи з ним у команді. Натомість добре оформлений код зі зрозумілими іменами, коментарями та єдиним стилем є набагато надійнішим і зручнішим у довгостроковій перспективі.
      Тут (Див. Додаток В.17) використано неочевидні змінні, відсутні коментарі, а сам стиль запису хаотичний. Такий код важко читати й підтримувати.
      Цей варіант (Див. Додаток В.18) охайний і зрозумілий: змінні мають інформативні назви, додана документація, використовується єдиний стиль оформлення. Такий підхід полегшує командну роботу та знижує ризик появи помилок. Приклади показують, що дотримання стандартів стилю та правил оформлення коду — це не формальність, а реальний спосіб зробити проєкт більш якісним і стійким у розвитку.
      

4. ВИСНОВКИ
      Під час роботи було практично підтверджено, що дотримання принципів чистого коду на R є важливим для створення якісного програмного забезпечення. Правильна структура коду, послідовне форматування та змістовне іменування елементів роблять код інтуїтивно зрозумілим і значно полегшують його читання як іншим розробникам, так і автору через певну годину. Використання констант замість "магічних чисел", реалізація механізмів обробки помилок та написання модульних тестів підвищують надійність програми та допомагають запобігати багатьом помилкам на ранніх етапах розробки. Документування функцій та змістовні коментарі є важливою інвестицією в майбутнє проекту, спрощуючи його підтримку та розширення. Інструменти автоматизації, такі як lintr та styler, забезпечують дотримання єдиних стандартів оформлення в команді, економлять годину і дозволяють розробникам зосередитися на вирішенні бізнес-завдань. В підсумку, застосування цих принципів у комплексі перетворює код на структурований, передбачуваний та легкий у супроводі продукт, що є основою для створення стабільного та довговічного програмного забезпечення.

5. СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ
     1. Wickham H. Advanced R. 2nd Edition. URL: https://adv-r.hadley.nz/ (date of access: 10.01.2025).
     2. Wickham H.R Packages. 2nd Edition. URL: https://r-pkgs.org/ (date of access: 10.01.2025).
     3. Tidyverse Style Guide. URL: https://style.tidyverse.org/ (date of access: 10.01.2025).
     4. R Manuals. The Comprehensive R Archive Network. URL: https://cran.r-project.org/manuals.html (date of access: 10.01.2025).
     5. lintr: Static Code Analysis for R. URL: https://lintr.r-lib.org/ (date of access: 10.01.2025).
     6. styler: Non-Invasive Pretty Printing of R Code. URL: https://styler.r-lib.org/ (date of access: 10.01.2025).
     7. testthat: Unit Testing for R. URL: https://testthat.r-lib.org/ (date of access: 10.01.2025).

ДОДАТОК А
Посилання відео на Youtube
Відеозапис доповіді: https://www.youtube.com/watch?v=IPs8005s05o
Хронологічний опис відеозапису:
0:00 - Вступ.
0:19 - Причини важливості правил оформлення коду.
0:59 - Структура коду. 
1:32 - Форматування коду. 
2:05 - Іменування змінних і функцій. 
2:34 - Константи та "магічні" числа. 
3:09 - Коментарі. 
3:23 - Документування функцій. 
3:42 - Обробка помилок. 
4:06 - Тестування. 
4:40 - Інструменти автоматизації. 
5:03 - Поганий vs Хороший код. 
5:36 - Висновки. 
6:10 - Списки використаних джерел.

ДОДАТОК Б
Слайди презентації


          











ДОДАТОК В
Програмний код
В.1 Модульна структура коду
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 data <- read.csv("file.csv")
3 summary(data)
4 plot(data)
5 # ... ще 200 рядків у одному файлі
6 
7 # Добре
8 source("data_load.R")
9 source("analysis.R")
10 source("visualization.R")

В.2 Форматування умовних конструкцій
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 if(x>0){print("positive")}else{print("negative")}
3 
4 # Добре
5 if (x > 0) {
6   print("positive")
7 } else {
8   print("negative")
9 }

В.3 Приклад неінформативних назв
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 a <- 10
3 f <- function(x) x * 2

В.4 Змістовне іменування змінних та функцій
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Добре
2 customer_age <- 10
3 multiply_by_two <- function(number) number * 2

В.5 Використання «магічних чисел»
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 discount_price <- price * 0.85 

В.6 Використання констант для ясності
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Добре
2 DISCOUNT_RATE <- 0.15
3 discount_price <- price * (1 - DISCOUNT_RATE)

В.7 Надлишкові коментарі
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 x <- x + 1  # додаємо 1
3 y <- y * 2  # множимо на 2

В.8 Змістовні коментарі, що пояснюють логіку
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Добре
2 # Корекція даних: зміщуємо всі значення на одиницю
3 x <- x + 1
4 
5 # Масштабування показників для нормалізації
6 y <- y * 2

В.9 Функція без докементації
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 f <- function(x, y){
3   x + y
4 }
5 # Що робить ця функція? Невідомо

В.10 Документування функції за допомогою roxygen2
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 #' Добре
2 #' Обчислює суму двох чисел
3 #' @param x перше число
4 #' @param y друге число
5 #' @return сума чисел
6 #' @examples
7 #' add_numbers(2, 3)
8 add_numbers <- function(x, y) {
9   x + y
10 }

В.11 Вразлива функція без обробки помилок
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 divide <- function(a, b) {
3   a / b
4 }
5 # Якщо b = 0, програма просто падає

В.12 Обробка помилок з stop() та tryCatch()
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Добре
2 safe_divide <- function(a, b) {
3   if (b == 0) stop("Помилка: ділення на нуль!")
4   a / b
5 }
6 
7 # Використання tryCatch для обробки
8 result <- tryCatch(
9   safe_divide(10, 0),
10   error = function(e) { message("Сталася помилка: ", e$message); NA }
11 )

В.13 Функція без модульних тестів
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 square <- function(x) {
3   x^2
4 }
5 # Ніяких тестів немає, помилки можуть залишитися непоміченими

В.14 Модульне тестування з пакетом
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Добре
2 library(testthat)
3 
4 square <- function(x) {
5   x^2
6 }
7 
8 test_that("square працює правильно", {
9   expect_equal(square(2), 4)
10   expect_equal(square(-3), 9)
11   expect_equal(square(0), 0)
12 })

В.15 Порушення стандартів стилю
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 myfunc<-function(x){x+1}
3 y=  2+3

В.16 Код, відформатований відповідно до стилю
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Добре
2 my_func <- function(x) {
3   x + 1
4 }
5 y <- 2 + 3


В.17 Поганий код: все разом і без пояснень
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 # Погано
2 f<-function(a,b){c=a+b;d=c/2;print(d)}
3 x=10;y=20;f(x,y)

В.18 Хороший код: структурований та документований
GitHub репозиторій: https://github.com/NureVdovenkoOleh/ark-pzpi-23-10-vdovenko-oleh/blob/main/Pract1/pzpi-23-10-vdovenko-oleh-pract1/code-examples-code-conventions.R
1 #' Добре
2 #' Обчислює середнє двох чисел і виводить його
3 #' @param a перше число
4 #' @param b друге число
5 #' @return середнє значення
6 mean_two_numbers <- function(a, b) {
7   result <- (a + b) / 2
8   print(result)
9 }
10 
11 x <- 10
12 y <- 20
13 mean_two_numbers(x, y)

26


